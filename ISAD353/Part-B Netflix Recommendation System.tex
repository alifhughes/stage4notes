\documentclass[a4paper]{article}
\usepackage[document]{ragged2e}
\begin{document}
\justify

POINT
EVIDENCE
EXPLAIN
LINK

Qu:
An overview of the application of NoSQL databases to recommendation systems \par
    The benefits of using it in these areas \par
Focus on providing details of actual examples of the application of NoSQL databases to Netflix's recommendation system \par
    which type of NoSQL applies and why \par
    What problems will arise \par

Overview of the application of NoSQL databases to recommendation systems (1000 words). \par
Discussion of the particular NoSQL database that you have chosen for your design, and why it is the best choice in this case (1000 words).\par
Discussion of issues arising with regard to handling the data (600 words). \par


\par
TODO: \par
- make sure each benefit is linked to an aspect of recommendation system \par
- link in benefits of neo4j into implementation \par
    - re look at implementation in consideration to the overview points \par
- write intro and conclusion \par
- add in facts and statistics \par
- CUT CUT CUT \par


\section{Introduction}
\label{sec:Introduction}
In the world of big data,
- companies need to stay competitive, the brand loyalty is becoming less and less
- in a way that benefits both them and and their customers
- to keep them interested and wanting more we should use these profiles that the companies get out of the big data
- to show that we know those customers, we know what you like, don't waste your time and our time or money in continuely searching for what you 'think' you want and instead, here is what you want based on what we know about you.

When you look at the companies that use graph databases as the core of their various products, you start to see some of the most successful companies in the world right now. Walmart for their shopping, PayPal for their peer to peer payment, Google ads and page ranking. Common themes throughout these companies is real-time, connected, big data, and Netflix is no exception. This again is where graph databases come into their own.

\section{Why graph against other NoSQL}
\label{sec:Why graph against other NoSQL}

When thinking about implementing a part of a system that is data-oriented, one has to understand the constraints, rate of change, size and what you want it to represent to decide which direction is best to take. If we were to apply this to the recommendation system of Netflix, we would soon realise that the amount of data is huge, offering 4,335 movies and 1,609 TV shows (Lovely, 2016), it is ever-changing, growing from 29 million subscribers worldwide in 2012 to 86 million in 2016 (Statista, 2016) and it is highly connected. Graph databases is the only system out of NoSQL or relational models that specialises in all of these outcomes. ADD SOMETHING SUGGESTING NEO4J OUT OF GRAPH DATABASES, it being market leader, already used by top companies bla bla\par

For the sake of comparison, the way in which it would be implemented in a relational model would first consist of all the tables for each of the element effecting the recommendation. This would include: users, movies and ratings where ratings would act as a join table. The problems arise however when you consider the questions presented about the data that we're using. From 2015 to 2016 third quarter's Netflix has seen a rise in 17.5 million subscribers worldwide (Statista, 2016) all of which are rating movies constantly. You can see how much the data grows and effects the growth of other data within that relational model to the point of saturation. To search these tables in real-time and to update them, to refresh the join tables constantly to reflect the new or modified data would be so computationally expensive it wouldn't make sense. Facebook discovered this first hand when working on there recommendation system for suggesting new friends, finding that when working with connected data, graph databases perform 1,000 times faster than relational database models (Rathle and Eifrem, 2013). Relational-models are known to be good at data that is well-structured and understood data, that doesn't require a lot of change and has minimal connectivity.

In the 2014 Cassandra summit, Netflix admitted to using Cassandra for 95\% of their database usages, this includes everything from storing meta data, customer data and even the recommendation system (Kalantzis, 2014). Along with them being able to create their own specialised adaptation of Cassandra due to their enormous development power, this is because other types of NoSQL approaches do help deal with some of these constraints. Largely, NoSQL databases by nature are able to deal with unstructured or semi-structured data very well. Options like document store databases or similar alternatives offer the ability to store information about an entity in a single 'document', without the need to split it into tables as you would with a relational-model. This benefits speed of reading and writing, however, I believe this is the least important of the constraints when working with recommender system. The edge that graph databases has over any NoSQL database model is the fact it specialises in connected and correlated data. The meaning of data comes from relationships between it. In a recommendation system, graph databases give a complete view of the user, movie, rating or description and all the data that is linked to it specifically, with the ability to exclude other data of the same subset, making it easy to understand everything about these aspects from all angles (De Marzi and Neo4j, 2015). The more we learn about the nodes, the greater the relevance and relationships are to one another which can be exploited for the gain of the company and user alike. \par

When dealing with big data, it is easy to be overwhelmed and to not be able to make sense of the data that is there due to the sheer amount of it. When such problems arise, Neo4J has the abstract benefit that it is very intuitive to design and implement. The schema that can easily be drawn out can be directly implemented into the actual graph database (Lyon and Neo4j, 2016). This opposed to other NoSQL that still require the mentality of data to be organised into entities with custom layout within and for it to be carefully indexed. Not having to do this allows for greater freedom and flexibility in the model of the database and ultimately benefits the system manipulating such data. It also helps the details not to be overlooked and the cognitive unload of not having to worry about implementation of the schema into strict rules allows the focus to be on what the data now represents.\par

This flexibility when accessing and manipulating data in Neo4J is reflected in the speed in which these operations can be performed. Being able to process the data that is in the graph database quickly is by far one of the biggest benefits when offering recommendations in real-time. This is possible due to the feature 'index-free adjacency' that Neo4J offers. That is, it doesn't need an index to be able to travel between nodes that are connected by a relationship (Merkl Sasaki and Neo4j, 2015). This saves expensive index look-ups that you have to use when working with other NoSQL models. What is unique to Neo4j and graph databases is that no matter the growth in data, the index-free adjacency allows 'constant-time traversal', meaning that the performance of the traversal of nodes will not change (Merkl Sasaki and Neo4j, 2015). This is especially important when you consider the rate of which the data held by Netflix grows. eBay found this to be true when they migrated their delivery system from MySql to Neo4J, their 'solution is literally thousands of times faster than the prior MySQL solution, with queries that require 10-100 times less code.' (Neo4j, 2016). \par

Neo4J realised when dealing with data that is so interconnected that older SQL syntax based language wouldn't suffice, they instead built their own query language, Cypher. Cypher optimised for Neo4J and its functionality contrasts the basic CRUD operations found in other NoSQL databases. Its main focus is pattern matching which is an important concept when working with big data as you want to be able to find patterns to make sense of what is there. This concept can directly be applied to recommendations as users build up patterns of movie watching habits and from those patterns one can draw out conclusions about what other movies to watch. The syntax of the language is designed to be close to natural language as to help with the intuitiveness, as it shifts the focus to what you actually want from the data, not how to do it. Queries are more concise, The Neo4J website gives examples of Cypher queries that are half or a quarter size in line count to their SQL equivalents (Hunger, Boyd, and Lyon, 2016). As the data and their connections grow exponentially, so do the SQL statements, unlike Cypher queries that stay concise which also means that they're easy and fast to implement, they're manageable and maintainable. When working with data that represents users and their movie preferences in relation to ratings and other users, one could see how large an SQL statement would start to become due to the amount of joins and clause conditions, so it is easy to realise the benefits of having a language built specifically to solve these issues. \par

As aforementioned, Netflix currently relies on Cassandra for almost all of its databases needs. This was chosen because Cassandra was built up from the ground with distributed data-centre storage as its focus, allowing constant up-time and availability (Kalantzis, 2014). This was an important step in the companies success as they made the transition to focus more on their streaming services rather than DVD rental and has since helped in their competitiveness. However, we are only focusing on one part of their massive ecosystem to try to improve it and to keep that same mindset, that all data needs to be available at all times, Neo4J has clustering as a core feature of its product. Clustering allows multiple machines with multiple instances to be grouped together. This ensures consistent throughput as multiple machines serve requests in parallel, that the data being replicated throughout the instances so there is nothing lost if one fails and requests can be re-routed if an instance is unavailable to ensure that request is served and that the data is always available (Borojevic, Lyon, and Neo4j, 2016). All of these are built in to the core of Neo4J making the recommendation system in-keeping with the always-available ethos of Netflix. \par

Being able to read and right in as ACID transaction is a feature which is specific to Neo4J (Chao, 2016). This is important to the success of a Netflix recommendation system as working with high volumes of sensitive data in real-time as data cannot be lost. However, you could argue the success of any database model would rely on how they store the data, that is after all the pure concept of a database. Neo4J offers native graph storage which allows for data consistency and also allows for all the performance optimisations to be possible (Chao, 2016). Simply put, if Neo4J didn't have this option, then none of the benefits above would be possible and therefore a different database system would have been argued for the recommendation system. \par


\section{Implementation}
\label{sec:Implementation}

There are two main models to consider when implementing a recommendation system. These are commonly known as Content based and Collaborative filtering. These are both methodologies to find ways of recommending items to the user but both take different approaches to do so.

Content based recommending is a model whereby the recommendations are made up of the comparison between multiple properties of the product. If two products are seen as similar based on the content that they share, then one can assume it is a candidate for recommendation (Recommender-Systems, 2012b). In context to graph databases and Netflix, the nodes would be the movies themselves as well as the descriptions. The relationships would link the movies to their respective descriptions. A query can be then used to find nodes of the same type that link to the same descriptor to find similar items. An example would be to return movie nodes that have the same 'genre' descriptor (Neo4j and Bachman, 2015). But, problems can arise from this approach. This is only recommending movies that are similar, that are in the same genre, by the same director and so on. This works to an extent, but people are not one-dimensional, in very few cases does a single person only like a single genre of movie. The user would soon grow tired seeing the same genre recommended and this would be detrimental to Netflix, as the trust in the recommendation starts to fail, other movies aren't discovered which leads to a misuse of the system and potential loss of a customer.

If movies are going to be linked on descriptions, then a standard, generalised and formalised taxonomy of description terms and classes is needed to rid the system of subjective bias. But even when standards are set, it can lead to scalability issues if one would like to add more descriptors to the items then it has to applied to all items otherwise it would never match on this property (Recommender-Systems, 2012b). Scoring algorithms can be applied to the bias problem to balance it over many people's opinions but that can be an expensive computation given the size of the dataset. Thus the bottlenecks of this approach are found. To circumnavigate this problem, the data that is applied to describe the movie can be from the source of the item itself, e.g. the movie production office provides the genre of the movie, which would provide a factual approach to describing the item without bias.

The collaborative filtering approach is were the system builds profiles of users based on their behaviours and actions, it then compares the users to form segments of similar users of which recommendations can be made based on actions made by other users of the same segments (Recommender-Systems, 2012a). Regularly on Netflix, users are asked to give ratings to the movies and in doing so it improves the correlation between segments. The system can assume that if one user of a segment rated a certain movie highly, then that movie can become a candidate for recommendation to other members of the segment Thus, the nodes of the graphs would include the users, which could be grouped together, and the relationships could be 'RATED', 'LIKED', 'WATCHED' to all the nodes of movies and descriptions (Neo4j and Bachman, 2015). This creating view of the user and their preferences in-line with other users of the same group. The use of a graph database makes these connections easy with the speed it can traverse the relationships and you can see that when working with this highly correlated and connected data that a graph database is the only solution. \par

Although this is a more natural way to approach the problem and can help to create a wider picture of the user and their preferences in relation to other users. This can again fall into the trap of of making users too one-dimensional (De Marzi and Neo4j, 2015). User preferences often change over time and this needs to be accounted for. A way to solve this is a commonly used technique known as 'Nearest neighbour' where the similarities between users of the group are ranked so the people with the highest similar taste in movies could be used against each other for recommendations (Recommender-Systems, 2012a). If this calculation of similarities was done across whole groups on a regular interval, you could account for the change in preferences per person as they move in similarity among one another and adjust the groups accordingly. This can also be used with machine learning techniques so that the score retrieved can be further improved upon. However, with a user base as large as Netflix, regulary tweaking the groups can be expensive process that continually has to happen for it to work effectively. The large user base also provides the problem of presenting the data real-time as users in a group have to be processed to find the informatin to make the recommendation, this can be aided with the help of pre-processing and optimisation techniques but it is still no doubt a extensive and expensive operation. It also takes time for the profile of a user to be built as Netflix doesn't ask for it at registration (Netflix, no date).

Most companies, however, try to adopt a combination of the two, merging data that describes the item along with the similarities between users. I would say this is the best course of action for Netflix recommender system as you get the advantages of both to gain valuable insights to the users, the movies that they like and the movies themselves. I also believe that Netflix could use meta-date to build up profiles on users quicker and more accurately. Information such as what time of the day they watched, what device they watched from and where they were when watching could give implicit ratings which would broaden the picture of the user and to find patterns of viewing habits and to make a richer image of the user. \par

Deciding which recommender methodology to use is only part of the whole system as the complete architecture incorporates many other aspects. These, defined by GraphAware (Neo4j and Bachman, 2015), can be broken down into the following steps: Model, Scoring, Blacklists, Filtering, Post-processing and Logging. All of these aspects of the system can be built with Neo4J. The Model is the actual graph database schema. It is how the data is represented in all of its entirety. This would be stored in the native graph storage to allow for index-free adjacency as well as other performance optimisations and would be modelled in conjunction with decision of the recommender system described above. The engine of the recommendation system in Neo4J would be written in one of the languages that is compatible with it: Java or Scala. Although it is been said that Netflix services are increasingly being changed from Java to Python (Samson, 2013) this does not mean that the service that handles the database and the engine would be a part of it, as they can encapsulate it to work with any other language that they use in different services. If they have already built their engine in Java, then the development overhead of incorporating the same language to build the Neo4J would be kept to a minimal. Scoring is an important feature of engine that Neo4J is able to implement. It allows for ranking of the results which provides the bases of how good a recommendation is, formulas and functions can be applied on top of this such as the Pareto distribution to account for differences of few being greater than differences of many within segment of users, as described in the collaborative filtering recommender (Weisstein, 2005). Post-processing techniques can also add to the weighting and score of the retrieved results, an example of this would be awarding extra points to the recommendations from user segment that are the same gender of the person requesting the recommendation thus, refining the recommendation more so. These parts of the engine can constantly be improved using data analysis techniques and machine learning due to it being a numerical figure and that the success of the recommendation being logged. When filtering, two technique are used to refine the results retrieved further, namely blacklisting and filters. Blacklisting is common technique that rids any data retrieved against a pre-defined 'list'. An example of this in recommendation systems would be the ability to exclude movies that have already been watched by the user. A filtering technique such as removing all results that are returned by users in the same group located in different countries, as Netflix only provides certian media in certain countries they would not apply to all users of a multinational segment. Finally, the benefits of logging allows the system to keep track of many aspects of the process throughout its journey through the engine and after the recommendation has been made. A notable example would be to log whether or not the user actually used the recommendation, if so, the wieghts and scores can be updated accordingly to further improve the engine. Thanks to the speed in which Neo4J allows graphs to be traversed, all of this can be done in real-time to present recommendations to the user as and when needed. However, techniques such as pre-computing would commonly be used to find the most optimal times to do these calculations before they're needed in real-time to balance the computational load of the process.

The power of this engine is obvious, once a query is made there are many layers of this engine that either strip, add, log or score the data retrieved from the model to produce only the most accurate results. This skeleton engine requirements produced by GraphAware, which is Neo4J's top consultancy firm, is in use for recommendation systems in LinkedIn and other top multinational companies (Graph Aware Limited, 2016).


Most NoSQL handle the growth and shrinkage of data easily, they can read and write to their data in great speeds, they can also provide valuable data distribution and protection. But they cannot solve the issue of connected data nor give the power to traverse the data to find and present the relationships that connect them together like graph databases can. \par
to conclude bring together the main points, without explanation, to emphasis why its only graph and only Neo4J that can be used


http://brettb.net/project/papers/2007%20The%20Netflix%20Prize.pdf
https://www.statista.com/statistics/250934/quarterly-number-of-netflix-streaming-subscribers-worldwide/
https://www.statista.com/topics/842/netflix/ (43.18 million subscribers in US alone)
\end{document}
